class StealthScene extends Phaser.Scene {
    constructor() {
        super({ key: 'StealthScene' });
    }

    init(data) {
        this.informantSpared = data.informantSpared; // Track player choice
        this.guardSpeed = this.informantSpared ? 100 : 200; // Adjust guard speed based on choice
    }

    create() {
        // Add background
        this.add.image(this.cameras.main.centerX, this.cameras.main.centerY, 'facility');

        // Add player
        this.player = this.physics.add.sprite(100, 400, 'jackal').setScale(0.5);
        this.player.setCollideWorldBounds(true); // Prevent player from going out of bounds

        // Add guards
        this.guards = this.physics.add.group();
        for (let i = 0; i < 3; i++) {
            const guard = this.physics.add.sprite(300 + (i * 150), 400, 'guard').setScale(0.5);
            guard.setCollideWorldBounds(true);
            this.guards.add(guard);

            // Add randomized patrol paths
            this.createGuardPatrol(guard, guard.x, guard.x + Phaser.Math.Between(100, 300));
        }

        // Add cover objects
        this.cover = this.physics.add.staticGroup();
        this.cover.create(300, 300, 'crate').setScale(0.5).refreshBody();
        this.cover.create(500, 400, 'crate').setScale(0.5).refreshBody();

        // Add collider between player and cover
        this.physics.add.collider(this.player, this.cover);

        // Add input for movement
        this.cursors = this.input.keyboard.createCursorKeys();
        this.sneakKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT);

        // Play tense music
        this.sound.play('dawnOfTheApocal', { loop: true });

        // Add footsteps sound
        this.footsteps = this.sound.add('footsteps', { loop: true });

        // Add detection meter
        this.detectionMeter = this.add.rectangle(
            this.cameras.main.centerX, // X position (center of the screen)
            50, // Y position (top of the screen)
            200, // Width of the meter
            20, // Height of the meter
            0xff0000 // Red color
        ).setOrigin(0.5, 0); // Set origin to center-top

        this.detectionProgress = 0; // Track detection progress (0 to 1)
    }

    createGuardPatrol(guard, startX, endX) {
        const minDistance = 100; // Minimum patrol distance
        if (Math.abs(endX - startX) < minDistance) {
            endX = startX + minDistance; // Adjust patrol distance
        }

        this.tweens.add({
            targets: guard,
            x: endX,
            duration: Phaser.Math.Between(1500, 2500) * (100 / this.guardSpeed), // Adjust speed
            yoyo: true,
            repeat: -1,
            ease: 'Linear',
            onYoyo: () => guard.flipX = !guard.flipX, // Flip sprite direction
            onRepeat: () => guard.flipX = !guard.flipX
        });
    }

    update() {
        // Player movement
        const speed = this.sneakKey.isDown ? 80 : 160; // Sneak mode reduces speed
        this.player.setVelocity(0);

        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        }

        if (this.cursors.up.isDown) {
            this.player.setVelocityY(-speed);
        } else if (this.cursors.down.isDown) {
            this.player.setVelocityY(speed);
        }

        // Play footsteps only when moving and not sneaking
        if ((this.player.body.velocity.x !== 0 || this.player.body.velocity.y !== 0) && !this.sneakKey.isDown) {
            if (!this.footsteps.isPlaying) {
                this.footsteps.play();
            }
        } else {
            this.footsteps.stop();
        }

        // Check guard vision and update detection meter
        let detected = false;
        this.guards.getChildren().forEach(guard => {
            const angleToPlayer = Phaser.Math.Angle.Between(guard.x, guard.y, this.player.x, this.player.y);
            const visionCone = Phaser.Math.DegToRad(45); // 45-degree vision cone

            if (Math.abs(angleToPlayer - guard.rotation) < visionCone) {
                const distance = Phaser.Math.Distance.Between(guard.x, guard.y, this.player.x, this.player.y);
                if (distance < 200 && !this.physics.overlap(this.player, this.cover)) { // Detection range
                    detected = true;
                }
            }
        });

        // Update detection progress
        if (detected) {
            this.detectionProgress += 0.01; // Increase detection progress
        } else {
            this.detectionProgress = Math.max(0, this.detectionProgress - 0.005); // Decrease detection progress
        }

        // Update detection meter visual
        this.detectionMeter.setScale(this.detectionProgress, 1);

        // Trigger alert if detection progress reaches 100%
        if (this.detectionProgress >= 1) {
            this.sound.play('alert');
            this.scene.start('QTEScene');
        }
    }
}
